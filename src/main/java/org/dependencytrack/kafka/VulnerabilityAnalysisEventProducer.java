package org.dependencytrack.kafka;

import alpine.common.logging.Logger;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.common.record.CompressionType;
import org.apache.kafka.common.serialization.StringSerializer;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.Project;
import org.dependencytrack.persistence.QueryManager;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.Future;

public class VulnerabilityAnalysisEventProducer {

    private static final Logger LOGGER = Logger.getLogger(VulnerabilityAnalysisEventProducer.class);

    private static final Producer<String, Object> producer;

    static {
        final var properties = new Properties();
        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        properties.put(ProducerConfig.CLIENT_ID_CONFIG, "FooBar");
        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JacksonSerializer.class.getName());
        properties.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, CompressionType.ZSTD.name);
        properties.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, false); // Causes issues with Redpanda when true
        producer = new KafkaProducer<>(properties);
    }

    public void publish(final Component component) throws Exception {
        publishInternal(component).get();
    }

    public void publish(final List<Component> components) throws Exception {
        final List<Future<RecordMetadata>> futures = new ArrayList<>();
        for (final Component component : components) {
            LOGGER.info("Publishing for component " + component.getUuid());
            futures.add(publishInternal(component));
        }

        for (final Future<RecordMetadata> future : futures) {
            final RecordMetadata meta = future.get();
            LOGGER.info("Event sent to topic " + meta.topic() + " partition " + meta.partition() + " at offset " + meta.offset());
        }
    }

    public void publish(final Project project) throws Exception {
        try (final var qm = new QueryManager()) {
            final var project1 = qm.getObjectById(Project.class, project.getId());
            final List<Component> components = qm.getAllComponents(project1);
            publish(qm.detach(components));
        }
    }

    private Future<RecordMetadata> publishInternal(final Component component) {
        return producer.send(new ProducerRecord<>("vulnerability-analysis", component.getUuid().toString(), component));
    }

}
