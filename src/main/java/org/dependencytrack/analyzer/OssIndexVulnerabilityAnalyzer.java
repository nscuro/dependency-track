package org.dependencytrack.analyzer;

import alpine.common.logging.Logger;
import alpine.common.util.Pageable;
import com.github.packageurl.MalformedPackageURLException;
import com.github.packageurl.PackageURL;
import org.dependencytrack.client.ossindex.ComponentReport;
import org.dependencytrack.client.ossindex.ComponentReportVulnerability;
import org.dependencytrack.client.ossindex.ModelConverter;
import org.dependencytrack.client.ossindex.OssIndexClient;
import org.dependencytrack.model.Component;
import org.dependencytrack.model.ComponentAnalysisCache.CacheType;
import org.dependencytrack.model.ComponentIdentity;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.Vulnerability.Source;
import org.dependencytrack.persistence.QueryManager;
import org.dependencytrack.tasks.scanners.AnalyzerIdentity;

import javax.jdo.Query;
import javax.json.Json;
import javax.json.JsonArray;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObject;
import javax.ws.rs.core.MultivaluedHashMap;
import javax.ws.rs.core.MultivaluedMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.UUID;

public class OssIndexVulnerabilityAnalyzer implements VulnerabilityAnalyzer {

    private static final Logger LOGGER = Logger.getLogger(OssIndexVulnerabilityAnalyzer.class);
    private static final int DEFAULT_BATCH_SIZE = 128;

    private final OssIndexClient client;
    private final int batchSize;

    public OssIndexVulnerabilityAnalyzer(final OssIndexClient client) {
        this(client, DEFAULT_BATCH_SIZE);
    }

    OssIndexVulnerabilityAnalyzer(final OssIndexClient client, final int batchSize) {
        this.client = client;
        this.batchSize = batchSize;
    }

    @Override
    public MultivaluedMap<ComponentIdentity, UUID> analyze(final Collection<ComponentIdentity> components) {
        final var coordinatesMap = new MultivaluedHashMap<String, ComponentIdentity>();
        for (final ComponentIdentity component : components) {
            if (component.getPurl() != null) {
                try {
                    coordinatesMap.add(minifyPurl(component.getPurl()), component);
                } catch (MalformedPackageURLException e) {
                    LOGGER.warn("Failed to minify PURL for " + component, e);
                }
            }
        }

        final var results = new MultivaluedHashMap<ComponentIdentity, UUID>();
        final Pageable<String> coordinatesPage = new Pageable<>(batchSize, new ArrayList<>(coordinatesMap.keySet()));
        int componentsAnalyzed = 0;

        while (!coordinatesPage.isPaginationComplete()) {
            final Collection<ComponentReport> reports = client.getComponentReports(coordinatesPage.getPaginatedList());

            for (final ComponentReport report : reports) {
                LOGGER.info("Processing ComponentReport for " + report.coordinates());
                final List<ComponentIdentity> matchedIdentities = coordinatesMap.get(report.coordinates());
                if (matchedIdentities == null) {
                    LOGGER.warn("No components match the coordinates " + report.coordinates());
                    continue;
                } else if (report.vulnerabilities() == null || report.vulnerabilities().isEmpty()) {
                    continue;
                }

                try (final var qm = new QueryManager()) {
                    JsonObject cache = null;

                    for (final ComponentReportVulnerability reportedVuln : report.vulnerabilities()) {
                        Vulnerability vuln;
                        if (reportedVuln.cve() != null) {
                            vuln = qm.getVulnerabilityByVulnId(Source.NVD, reportedVuln.cve());
                            if (vuln != null) {
                                // TODO
                            } else {
                                vuln = qm.createVulnerability(ModelConverter.convert(qm, reportedVuln), false);
                            }
                        } else {
                            vuln = qm.getVulnerabilityByVulnId(Source.OSSINDEX, reportedVuln.id());
                            if (vuln == null) {
                                vuln = qm.createVulnerability(ModelConverter.convert(qm, reportedVuln), false);
                            }
                        }

                        for (final ComponentIdentity identity : matchedIdentities) {
                            results.add(identity, vuln.getUuid());
                            addVulnerability(qm, identity, vuln);
                        }

                        cache = addVulnerabilityToCache(cache, vuln.getId());
                    }

                    updateComponentAnalysisCache(qm, report.coordinates(), cache);
                }
            }

            componentsAnalyzed += coordinatesPage.getPageSize();
            LOGGER.info("Components analyzed: " + componentsAnalyzed + "/" + coordinatesPage.getList().size());

            coordinatesPage.nextPage();
        }

        return results;
    }

    @Override
    public AnalyzerIdentity getIdentity() {
        return AnalyzerIdentity.OSSINDEX_ANALYZER;
    }

    private String minifyPurl(final PackageURL purl) throws MalformedPackageURLException {
        return new PackageURL(purl.getType(), purl.getNamespace(), purl.getName(), purl.getVersion(), null, null).canonicalize();
    }

    private JsonObject addVulnerabilityToCache(final JsonObject cache, final long vulnId) {
        if (cache == null) {
            final JsonArray vulns = Json.createArrayBuilder().add(vulnId).build();
            return Json.createObjectBuilder().add("vulnIds", vulns).build();
        } else {
            final JsonArrayBuilder vulnsBuilder = Json.createArrayBuilder(cache.getJsonArray("vulnIds"));
            final JsonArray vulns = vulnsBuilder.add(Json.createValue(vulnId)).build();
            return Json.createObjectBuilder(cache).add("vulnIds", vulns).build();
        }
    }

    private void updateComponentAnalysisCache(final QueryManager qm, final String coordinates, final JsonObject result) {
        LOGGER.info("Updating cache for " + coordinates + ": " + result);
        qm.updateComponentAnalysisCache(CacheType.VULNERABILITY, client.getApiBaseUrl(),
                Source.OSSINDEX.name(), coordinates, new Date(), result);
    }

    private void addVulnerability(final QueryManager qm, final ComponentIdentity identity, final Vulnerability vuln) {
        final Query<Component> query = qm.getPersistenceManager().newQuery(Component.class);
        query.setFilter("purl == :purl");
        query.setParameters(identity.getPurl().toString());
        for (final Component component : query.executeList()) {
            LOGGER.info("Adding vulnerability " + vuln.getVulnId() + " to component " + component);
            qm.addVulnerability(vuln, component, AnalyzerIdentity.OSSINDEX_ANALYZER);
        }
        query.closeAll();
    }

}
